#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

// DFS helper to compute height and update diameter
int dfs(TreeNode* root, int &diameter) {
    if (!root) return 0;

    int leftHeight = dfs(root->left, diameter);
    int rightHeight = dfs(root->right, diameter);

    // Update diameter: longest path passing through this node
    diameter = max(diameter, leftHeight + rightHeight);

    // Return height of this node
    return 1 + max(leftHeight, rightHeight);
}

int user_logic(TreeNode* root) {
    int diameter = 0;
    dfs(root, diameter);
    return diameter;
}

// Construct binary tree from given input
TreeNode* construct_tree(int i, const vector<pair<int, int>>& nodes) {
    if (i < 0 || i >= nodes.size() || nodes[i].first == -1 && nodes[i].second == -1) {
        return new TreeNode(i + 1);
    }
    TreeNode* node = new TreeNode(i + 1);
    if (nodes[i].first != -1) {
        node->left = construct_tree(nodes[i].first - 1, nodes);
    }
    if (nodes[i].second != -1) {
        node->right = construct_tree(nodes[i].second - 1, nodes);
    }
    return node;
}

int main() {
    int n;
    cin >> n;
    vector<pair<int, int>> nodes(n);
    for (int i = 0; i < n; ++i) {
        cin >> nodes[i].first >> nodes[i].second;
    }

    TreeNode* root = construct_tree(0, nodes);
    int result = user_logic(root);
    cout << result << endl;

    return 0;
}
