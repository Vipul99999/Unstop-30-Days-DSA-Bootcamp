#include <bits/stdc++.h>
using namespace std;

struct Node {
    int key;
    Node* left;
    Node* right;
    Node(int k) : key(k), left(nullptr), right(nullptr) {}
};

// Build BST from postorder iteratively
Node* buildBST(vector<int>& postorder) {
    int n = postorder.size();
    if (n == 0) return nullptr;

    Node* root = new Node(postorder[n-1]);
    stack<Node*> st;
    st.push(root);

    for (int i = n-2; i >= 0; i--) {
        Node* node = new Node(postorder[i]);
        Node* temp = nullptr;

        while (!st.empty() && postorder[i] < st.top()->key) {
            temp = st.top();
            st.pop();
        }

        if (temp) temp->left = node;
        else st.top()->right = node;

        st.push(node);
    }

    return root;
}

// Level-order traversal to get second-last row
vector<int> secondLastRow(Node* root) {
    if (!root) return {};
    vector<vector<int>> levels;
    queue<Node*> q;
    q.push(root);

    while (!q.empty()) {
        int sz = q.size();
        vector<int> level;
        for (int i = 0; i < sz; i++) {
            Node* node = q.front();
            q.pop();
            level.push_back(node->key);
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        levels.push_back(level);
    }

    if (levels.size() < 2) return {};
    return levels[levels.size() - 2]; // second-last row
}

int main() {
    int n;
    cin >> n;
    vector<int> postorder(n);
    for (int i = 0; i < n; i++) cin >> postorder[i];

    Node* root = buildBST(postorder);
    vector<int> res = secondLastRow(root);

    for (int x : res) cout << x << " ";
    cout << "\n";
}
