#include <bits/stdc++.h>
using namespace std;

const int MAXN = 2e5 + 5;
vector<int> tree[MAXN];
int dp0[MAXN], dp1[MAXN];
int N;
int max_match;

// First DFS: compute dp0 and dp1
void dfs1(int u, int p) {
    dp0[u] = 0;
    dp1[u] = 0;
    vector<int> child;
    for (int v : tree[u]) {
        if (v == p) continue;
        dfs1(v, u);
        dp0[u] += max(dp0[v], dp1[v]);
        child.push_back(v);
    }
    for (int v : child) {
        int val = 1 + dp0[v] + (dp0[u] - max(dp0[v], dp1[v]));
        dp1[u] = max(dp1[u], val);
    }
}

// Second DFS: count removable nodes
int removable_count = 0;
void dfs2(int u, int p, int parent_contrib) {
    // Maximum matching excluding u
    int match_excl_u = 0;

    vector<int> children;
    for (int v : tree[u]) if (v != p) children.push_back(v);

    // Compute prefix & suffix sums of max(dp0, dp1) of children for fast calculation
    int sz = children.size();
    vector<int> pre(sz+2, 0), suf(sz+2, 0);
    for (int i=0;i<sz;i++) pre[i+1] = pre[i] + max(dp0[children[i]], dp1[children[i]]);
    for (int i=sz-1;i>=0;i--) suf[i] = suf[i+1] + max(dp0[children[i]], dp1[children[i]]);

    // Node u removed
    match_excl_u = parent_contrib + pre[sz];  // sum of max(dp0, dp1) of all children + parent's contribution

    if (match_excl_u == max_match) removable_count++;

    // Recurse for children
    for (int i=0;i<sz;i++){
        int v = children[i];
        int excl_v = parent_contrib + 1 + dp0[u] - max(dp0[v], dp1[v]); 
        // parent_contrib = contribution from above
        // +1 for matching parent to some other child? (complex cases ignored)
        // Actually we just propagate parent_contrib + sum of siblings' max(dp0, dp1)
        int siblings = pre[i] + suf[i+1];
        dfs2(v, u, siblings + parent_contrib);
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> N;
    for (int i=0;i<N-1;i++){
        int u,v; cin>>u>>v;
        tree[u].push_back(v);
        tree[v].push_back(u);
    }

    dfs1(1,0);
    max_match = max(dp0[1], dp1[1]);

    dfs2(1,0,0);

    cout << removable_count << "\n";
    return 0;
}
